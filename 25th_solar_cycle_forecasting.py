# -*- coding: utf-8 -*-
"""25th Solar Cycle Forecasting

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CFkp7OaIzDbJrpZHAbLG3hG9xHmtkb-V

# Forecasting the 25th Solar Cycle

## Sunspots and Solar cycles
Solar cycle predictions rely on indicators such as sunspot numbers. Sunspots have been observed for thousands of years, from ancient Chinese astronomers, to the likes of Kepler and Galileo, to modern state-of-the-art solar observatories. Even amateur astronomers can view sunspots.

<img src='https://arxiv.org/html/2502.00978v1/extracted/6155983/Figure1.png' >
Figure 1:Viewing sunspots is easy, predicting them is not. This image by the author shows a sunspot region cluster near solar maximum.

Only in the last century has a well-founded physical interpretation for these features been given; that sunspots are vast, cool(er) regions on the solar surface or photosphere, resulting from the self-sustaining global solar magnetic field. Sunspots are indicative of solar activity because the number of sunspots present at a given time varies over the course of a cycle, increasing toward solar maximum (the peak of solar activity) and decreasing toward solar minimum.

## Cycle 25 predictions
With the newest data and the latest in solar dynamo science and modelling tools, numerous predictions for the maximum sunspot number or ‚Äòamplitude‚Äô and timing of cycle 25 were made (Fig. 3). A search of the Astrophysics Data System and others returned more than a hundred cycle 25 predictions published between 1983 and 2024, with most published after 2015. Excluding predictions based on the obsolete version 1 of the sunspot number series, the average prediction for the amplitude of cycle 25 was 127 units of sunspot number, ranging from 50 on the lower end to 233 on the upper.

## How accurate were these predictions?
As of this writing, sunspot number data are available through January 2025. So far, the highest smoothed value is 154.9 for July 2024, and the highest raw value for a given month is 216 for August 2024. These values already exceed the average prediction for cycle 25 of 127. In fact, only a handful of predictions captured the August 2024 spike in solar activity (Fig. 3). The average peak sunspot number across cycles 1 through 24 was 178.7; this historical baseline is closer to the July and August 2024 values than the vast majority of published predictions for cycle 25‚Äôs amplitude.

Put simply, most predictions underestimated cycle 25, some massively so, perhaps because models were led astray by the weakness of the previous cycle 24. This is somewhat opposite to the case for predictions of cycle 24, many of which overestimated that cycle‚Äôs amplitude, perhaps because of how strong cycles 21 through 23 were (for a review, see [2]). Some authors also made multiple predictions in the same publication, which may not be terribly informative for those relying on forecasts.

Fewer predictions were made for the timing of solar maximum, but the timing predictions seem to have performed better than the amplitude predictions (Fig. 4). Although the actual timing of cycle 25‚Äôs solar maximum is still unknown as of this writing, it is now thought to occur some time in 2025 (or may have already peaked in 2024), and a number of published predictions did include 2025 in their wide error bounds.

## The Problem
Although it is tempting to think that the existence of an eleven-year cycle, as well as apparent longer-term trends in solar activity, make the solar cycle phenomenon predictable, the reality is more complicated. The cycles observed so far are not all the same duration, and the peak does not occur at the same point for each cycle. In fact, cycles can have multiple peaks, and the gradient of ascent of sunspot numbers varies considerably. In short, there is an element of apparent randomness in solar cycles. Another complication is that most models are based on the ‚Äòsmooth‚Äô sunspot number that results from averaging across months of observation; this makes sense from a modelling perspective, but since solar activity can vary dramatically from month-to-month, models of smoothed data cannot predict sudden bursts of solar activity, which are nevertheless important to know about.



Solar activity may be semi-unpredictable due to (a) hidden or inaccessible variables, or (b) patterns yet to be observed given insufficient observations; recall that sunspot numbers have only been counted for around 300 years (and some of these observations may have variable reliability), while solar activity is likely to have been undergoing cycles for billions of years. Only a tiny fraction of solar cycles have been observed. Either one of the above scenarios would confound long-term solar cycle prediction; both would be a disaster for accurate long-term prediction.

## The Consequences
Failing to predict the timing and amplitude of a solar cycle may seem relatively innocuous, in any case because solar activity is beyond our control. It would be far more harmful, say, to inaccurately forecast the public health impact of authorizing a new drug product. However, poor solar forecasting is not without harm.

First, the space sector relies on accurate and timely solar forecasts to plan satellite programs and other space missions and operations. Second, ground-based sectors such as those involved in radio communications, electrical power transmission and transformation, and even estimating climatic impacts are similarly dependent on solar activity predictions.

Thirdly, and often overlooked, is the impact of miscalculation on public trust in science. In a time of eroding public trust in experts, solar/space science does not want to go the way certain other fields have gone (rightly or wrongly) in terms of public confidence, which may in turn impact funding, much of which is ultimately determined politically.

Now, its time to get our hands on the data.

### Importing Libraries
"""

# BASE
# ------------------------------------------------------
import numpy as np
import pandas as pd
import os
import gc
import warnings

# PACF - ACF
# ------------------------------------------------------
import statsmodels.api as sm

# DATA VISUALIZATION
# ------------------------------------------------------
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import matplotlib.dates as mdates

"""### Importing Dataset for Forecasting"""

from google.colab import drive
drive.mount('/content/drive')
file_path = '/content/drive/MyDrive/Deekshitha/Datasets/monthly_mean.csv'
print(os.path.exists(file_path))

data = pd.read_csv('/content/drive/MyDrive/Deekshitha/Datasets/monthly_mean.csv', sep=';')
data.columns = ['Year', 'Month', 'Date in Fraction', 'Mean Sunspot Number', 'Mean SD', 'Observation','Marker']
subset = data[['Year', 'Month', 'Mean Sunspot Number']]
ss1=subset.iloc[12:].reset_index(drop=True)
ss1['Date'] = pd.to_datetime(ss1[['Year', 'Month']].assign(DAY=1))
ss1.set_index('Date', inplace=True)
ss1.head(15)

sns.lineplot(x='Date', y='Mean Sunspot Number', data=ss1)

plt.xlabel('Year')
plt.ylabel('Monthly Mean Sunspot Number')
plt.title('Solar Activity from 1750\'s till 2024')
plt.xticks(pd.date_range(start=ss1.index.min(), end=ss1.index.max(), freq='25Y'))
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""## Dataset
‚ÄãThe Solar Flare Index (SFI) is a metric developed by the Kandilli Observatory to quantify solar flare activity based on full-disk H-alpha observations. It combines the flare's optical importance (brightness and area) with its duration to estimate the total energy emitted by solar flares. The SFI data from the Kandilli Observatory are available in daily, monthly, and yearly resolutions. These datasets are part of a composite record that spans from 1937 to 2020, incorporating data from both the Ondrejov Observatory (1937‚Äì1976) and the Kandilli Observatory (1977‚Äì2020).
<br>
Flare Index (Kandilli)
What it measures: It quantifies solar flare activity using H-alpha observations (visible light).

Formula:

Flare¬†Index
=
ùëñ
√ó
ùë°
Flare¬†Index=i√ót
Where:

i = flare importance (a value based on intensity and area)

t = duration in minutes

It‚Äôs a custom index, specific to flare activity ‚Äî calculated daily, monthly, and yearly.
"""

from google.colab import files
uploaded = files.upload("C:\\Users\\WORK STATION\\Downloads\\Internships\\ISRO internship\\Solar Cycle Forecasting")

import matplotlib
from matplotlib import pyplot as plt
import numpy as np
matplotlib.rcParams["figure.dpi"] = 1000
import seaborn as sns
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.stattools import adfuller

xy = []
yy = []
for j in range(1976,2024):
    with open(r"/content/C:\Users\WORK STATION\Downloads\Internships\ISRO internship\Solar Cycle Forecasting/"+str(j)+".txt", mode="r") as f:
        value = float(f.readlines()[-1].split("\t")[1])
        xy.append(j)
        yy.append(value)

fig, ax = plt.subplots()
sns.lineplot(x=xy,y=yy,lw=0.8)
sns.despine()
ax.set(xlabel='Time (years)', ylabel='Solar Flare Index')
plt.savefig('yearly_variations.png', dpi=2000, bbox_inches='tight')
plt.show()

xm = []
ym = []
for j in range(1976,2024):
    with open(r"/content/C:\Users\WORK STATION\Downloads\Internships\ISRO internship\Solar Cycle Forecasting/"+str(j)+".txt", mode="r") as f:
        lines = f.readlines()
        line = lines[-3].strip()
        for v in line.split("\t")[1:]:
            ym.append(float(v))
        for i in range(12):
            xm.append(j+1.00*i/12.00)

fig, ax = plt.subplots()
sns.lineplot(x=xm,y=ym,lw=0.8)
sns.despine()
ax.set(xlabel='Time (years)', ylabel='Solar Flare Index')
plt.savefig('monthly_variations.png', dpi=2000, bbox_inches='tight')
plt.show()

x = []
y = []
ymstd = [] #y std monthly
for j in range(1976,2024):
    with open(r"/content/C:\Users\WORK STATION\Downloads\Internships\ISRO internship\Solar Cycle Forecasting/"+str(j)+".txt", mode="r") as f:
        lines = f.readlines()[7:]
        mat = []
        for line in lines[:-4]:
            if line[0] == '\n': continue
            l = line.split("\t")
            l[-1] = l[-1].strip()
            for i in range(len(l)):
                if l[i] == '': l[i] = -1
                l[i] = float(l[i])
            mat.append(l[1:13])
        mat = np.matrix(mat).transpose() #reordering
        #calculate variance and +- 1*sigma values per month
        for v in mat:
            v = v.tolist()[0]
            v = [i for i in v if i >= 0]
            ymstd.append(np.std(v))
        days = mat.flatten().tolist()[0] #turn it into a 1D array
        days = [i for i in days if i >= 0]
        ndays = len(days)
        for i in range(ndays):
            y.append(days[i])
            x.append(j+1.00*i/(ndays*1.00))

#extra calculations for upper and lower bounds
ns = 1 #number of sigmas. Default is 1.
yupp = np.array(ym)+ns*np.array(ymstd)
ylow = np.array(ym)-ns*np.array(ymstd)
zeros = np.ndarray(ylow.shape)
def ylowhelper(i):
    if i<0: return 0
    else: return i
vctrd = np.vectorize(ylowhelper)
ylow = vctrd(ylow)

fig, ax = plt.subplots()
sns.lineplot(x=x,y=y,lw=0.1,label="Daily values")
sns.despine()
sns.lineplot(x=xm,y=ym,lw=0.7,label="Monthly Averages")
sns.lineplot(x=xm,y=yupp,lw=0.4,label="Upper bound")
sns.lineplot(x=xm,y=ylow,lw=0.4,label="Lower bound")
plt.fill_between(x=xm,y1=ylow,y2=yupp,color='white', alpha=0.5) #TODO
# sns.set(font_scale=1)
ax.set(xlabel='Time (years)', ylabel='Solar Flare Index')
plt.legend()
plt.savefig('daily_variations.png', dpi=2000, bbox_inches='tight')
plt.show()

# Check for stationality (Dickey-Fuller ADF test)
t = adfuller(ym)
print('ADF Statistic:', t[0])
print('p-value:', t[1]) #we obtain p>0.05, but close to it.
#But if we look into the daily series...
t = adfuller(y)
print('ADF Statistic:', t[0])
print('p-value:', t[1]) #we obtain p<<<0.05. So we will consider ym to also be stationary.

def get_loglike(v):
    b = v.as_csv().split("\n")
    b = b[2].split(",")[-1]
    return float(b)

model = ARIMA(ym, order=(24, 0, 2))
model_fit = model.fit()
# Print the model summary
model_fit.summary()

print(get_loglike(model_fit.summary()))

def generate_months_pred(n,last_date):
    months_pred = n
    start = len(ym)
    end = start + months_pred-1
    xpred = []
    for i in range(months_pred):
        xpred.append(last_date+i/12)
    return xpred

ARMATIME = 6*12
predictions = model_fit.predict(start=len(ym), end=len(ym)+ARMATIME-1)

sns.lineplot(x=xm,y=ym,lw=0.7,label="Monthly values")
xpred = generate_months_pred(ARMATIME,x[-1])
sns.lineplot(x=xpred,y=predictions,lw=0.7,label="ARMA predictions")
ax.set(xlabel='Time (years)', ylabel='Solar Flare Index')
plt.legend()
plt.savefig('ARMA.png', dpi=2000, bbox_inches='tight')
plt.show()

p, d, q = 1, 1, 1
P, D, Q, s = 1, 1, 1, 12*11  # Assuming 11 year seasonality

# Fit the SARIMA model
model = SARIMAX(ym, order=(p, d, q), seasonal_order=(P, D, Q, s))
results = model.fit()
model

print(results.summary())

# Forecast future values
forecast_periods = 12*15  # Forecast the next 15 years
forecast = results.get_forecast(steps=forecast_periods)
forecast_mean = forecast.predicted_mean
forecast_ci = forecast.conf_int()
fclow = vctrd(forecast_ci.transpose()[0])
fcupp = forecast_ci.transpose()[1]

xmnew = generate_months_pred(forecast_periods, x[-1])

# Plot the forecast
fig, ax = plt.subplots()
sns.lineplot(x=xm, y=ym, label='Observed',lw=0.5)
sns.lineplot(x=xmnew, y=vctrd(forecast_mean), label='SARIMA Forecast', color='red',lw=0.5)
#plt.fill_between(xmnew, fclow, fcupp, color='pink')
ax.set(xlabel='Time (years)', ylabel='Solar Flare Index')
plt.legend()
plt.savefig('SARIMA.png', dpi=2000, bbox_inches='tight')
plt.show()

def mat_model(xi):
    #args1
    A=7.5
    w=11
    off=1976
    off2=6.3
    #args2
    w2=w*8
    A2=0.5
    B2=0.2
    off3=-6
    #overall
    alpha = 1/16
    return alpha*((A+np.cos((xi-off+off2)*2*np.pi/w)*A)**2)*(B2+A2+np.cos((xi-off+off3)*2*np.pi/w2)*A2)
v2 = np.vectorize(mat_model)

# Plot everything together
fig, ax = plt.subplots()
sns.lineplot(x=xm, y=ym, label='Observed',lw=0.5)
sns.lineplot(x=xmnew, y=vctrd(forecast_mean), label='Forecast SARIMA', color='black',lw=0.5)
sns.lineplot(x=xm+xmnew, y=v2(xm+xmnew), label='Forecast MathModel', color='red',lw=0.5)
MA_size=12
sns.lineplot(x=(xm+xmnew), y=np.convolve(ym+vctrd(forecast_mean).tolist(),np.ones(MA_size)/MA_size)[:-MA_size+1], label='Moving average of data', color='purple',lw=0.5)
#plt.fill_between(xmnew, fclow, fcupp, color='pink')
ax.set(xlabel='Time (years)', ylabel='Solar Flare Index')
plt.legend()
plt.savefig('MathModel.png', dpi=2000, bbox_inches='tight')
plt.show()